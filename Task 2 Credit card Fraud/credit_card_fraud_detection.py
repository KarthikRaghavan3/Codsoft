# -*- coding: utf-8 -*-
"""Credit Card Fraud Detection.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xHk8NNIS65eUWHZ58LOGfoUGC_gLheLy
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from google.colab import drive
drive.mount('/content/drive')
from matplotlib import style
style.use('ggplot')

import warnings
warnings.filterwarnings('ignore')

# %matplotlib inline

train = pd.read_csv("/content/drive/MyDrive/credit-data/fraudTrain.csv")
test = pd.read_csv("/content/drive/MyDrive/credit-data/fraudTest.csv")

train.head() # top 5 rows are displayed

test.head()

#combined for data cleaning and visualization
data = pd.concat([train,test], axis = 0) #axis = 0 means row wise(stacked vertically)
data.head()

data.info()

data.reset_index(inplace = True)
data.head(10)

data.info()

data.duplicated().sum() #for checking duplicate values

data.isnull().sum() # checking for null values

data = data.drop(['index', 'Unnamed: 0'], axis = 1)  #for removing columns

data.describe()

plt.figure(figsize = (12,6), dpi = 200)
sns.countplot(x = data['is_fraud'])

plt.figure(figsize = (12,6), dpi = 200)
sns.countplot(x = 'gender', hue = 'is_fraud', data = data) #fraud w.r.t gender plot

plt.figure(figsize = (16,8), dpi = 200)
sns.countplot(x = 'category', hue = 'is_fraud', data = data)
plt.xticks(rotation = 60)
plt.show()

data.head()

X = data.drop(['is_fraud'], axis = 1) # Creating dependant and independant features dataset
Y = data['is_fraud']

# the encoding class encodes categorical data into quantifiable values, Eg. : low = 0, med = 1, high = 2
from sklearn.preprocessing import OrdinalEncoder
cols = ['trans_date_trans_time', 'merchant', 'category', 'first', 'last', 'gender', 'street', 'city', 'state', 'job', 'dob', 'trans_num']
encoder = OrdinalEncoder()
X[cols] = encoder.fit_transform(X[cols])

# Scaling means adjusting the values to similar proportional range and preventing some features from dominating others due to their larger magnitudes.
from sklearn.preprocessing import MinMaxScaler
scaler = MinMaxScaler()
X = scaler.fit_transform(X)

Y = data[['is_fraud']].values

print('Independant Feautres Shape: ', X.shape)
print('Dependant Feautres Shape: ', Y.shape)

data['is_fraud'].value_counts() # Resampling as dataset is highly unbalanced (gives count of unique values)

#Using Oversampling using SMOTE( Synthetic Minority Oversampling Technique )
from imblearn.over_sampling import SMOTE
smote_sampler = SMOTE()
x_sampled, y_sampled = smote_sampler.fit_resample(X, Y)

print('Data : ', x_sampled.shape)
print('Labels : ', y_sampled.shape)

from sklearn.model_selection import train_test_split
x_train, x_test, y_train, y_test = train_test_split(x_sampled, y_sampled, test_size = 0.2, random_state = 2)

print('Training Data Shape   : ', x_train.shape)
print('Training Labels Shape : ', y_train.shape)
print('Testing Data Shape    : ', x_test.shape)
print('Testing Labels Shape  : ', y_test.shape)

"""**Logistic Regression**"""

from sklearn.linear_model import LogisticRegression
lr_classifier = LogisticRegression()
lr_classifier.fit(x_train, y_train)

from sklearn.metrics import accuracy_score
from sklearn.metrics import f1_score
from sklearn.metrics import recall_score
from sklearn.metrics import precision_score
pred_train = lr_classifier.predict(x_train)
pred_test = lr_classifier.predict(x_test)

print('Training Accuracy: ', accuracy_score(y_train, pred_train)) #computes how many predictions are correct in pred_train w.r.t y_train
print('Testing Accuracy: ', accuracy_score(y_test, pred_test)) #computes how many predictions are correct in pred_test w.r.t y_test

print('Training Set f1 score: ', f1_score(y_train, pred_train))
print('Testing Set f1 score: ', f1_score(y_test, pred_test))

print('Test Set precision: ', precision_score(y_test, pred_test))
print('Test Set recall: ', recall_score(y_test, pred_test))

from sklearn.metrics import confusion_matrix
from sklearn.metrics import ConfusionMatrixDisplay
cm = confusion_matrix(y_test, pred_test)
display_labels = ["non_fraud(0)", "fraud(1)"]


plt.figure(figsize = (6,3), dpi = 100)
sns.set(rc = {'axes.grid' : False}) #for turning off grid lines in the plot
disp = ConfusionMatrixDisplay(confusion_matrix = cm, display_labels = display_labels)
disp.plot()

"""**Decision Tree Classification**"""

from sklearn.tree import DecisionTreeClassifier
dt_classifier = DecisionTreeClassifier(max_depth = 50, random_state = 100)
dt_classifier.fit(x_train, y_train)

pred_train = dt_classifier.predict(x_train)
pred_test = dt_classifier.predict(x_test)

print('Training Accuracy: ', accuracy_score(y_train, pred_train))
print('Testing Accuracy: ', accuracy_score(y_test, pred_test))

print('Training f1 score: ', f1_score(y_train, pred_train))
print('Testing f1 score: ', f1_score(y_test, pred_test))

print('Test Set precision: ', precision_score(y_test, pred_test))
print('Test Set recall: ', recall_score(y_test, pred_test))

cm = confusion_matrix(y_test, pred_test)
display_labels = ['no_fraud(0)', 'fraud(1)']

plt.figure(figsize = (6,3), dpi = 100)
sns.set(rc = {'axes.grid' : False})
disp = ConfusionMatrixDisplay(confusion_matrix = cm, display_labels = display_labels)
disp.plot()

"""**Random Forest Classification**"""

from sklearn.ensemble import RandomForestClassifier
rf_classifier = RandomForestClassifier(n_estimators = 20, random_state = 2)
rf_classifier.fit(x_train, y_train)

pred_train = rf_classifier.predict(x_train)
pred_test = rf_classifier.predict(x_test)

print('Training Accuracy: ', accuracy_score(y_train, pred_train))
print('Testing Accuracy: ', accuracy_score(y_test, pred_test))

print('Training f1 score: ', f1_score(y_train, pred_train))
print('Testing f1 score: ', f1_score(y_test, pred_test))

print('Test Set Precision: ', precision_score(y_test, pred_test))
print('Test Set recall: ', recall_score(y_test, pred_test))

cm = confusion_matrix(y_test, pred_test)
display_labels = ['no_fraud(0)', 'fraud(1)']

plt.figure(figsize = (6,3), dpi = 100)
sns.set(rc = {'axes.grid' : False})
disp = ConfusionMatrixDisplay(confusion_matrix = cm, display_labels = display_labels)
disp.plot()